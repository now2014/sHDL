#' Maximize the log likelihood to infer the heritability enrichment fold(s).
#'
#' @param ref.data A list of data matched to LD reference generated by \code{\link{sHDL.joint.reduct.dim}}.
#' @param start.v Starting values for \code{c(h2, intercept, eta, fold1, fold2, ..., foldn)}, where n is the number of annotations. Default is \code{NULL}, which means \code{c(0.1, 1, 0, 1, ..., 1)}. If \code{fix.h2}, \code{fix.intercept} or \code{fix.eta} is not \code{NULL}, the starting values for \code{h2}, \code{intercept} or \code{eta} will be ignored.
#' @param N The sample size of the GWAS.
#' @param annots A vector of annotation names, default \code{NULL}, which means all annotations in the \code{Dr.path} will be used.
#' @param lam.cut Cutoff for the eigenvalues, default is \code{NULL}, which means no cutoff. For analyses with a limited number of traits and annotations, a lower cutoff (such as 0.1, or even not using a cutoff at all) is recommended. For large-scale analyses, a higher cutoff (such as 1)  is recommended, to yield fast computation.
#' @param output.file Where the results should be written.
#' @param log.file Where the log should be written.
#' @param stepwise Whether to estimate enrichment fold by estimating heritability and intercept first, default \code{stepwise = FALSE}. If \code{fix.h2}, \code{fix.intercept} and \code{fix.eta} are not \code{NULL}, \code{stepwise} will be overridden.
#' @param fix.h2 Whether to fix the heritability to \code{fix.h2} or estimate the heritability, default \code{fix.h2 = NULL}, which means estimate the heritability.
#' @param fix.intercept Whether to fix the intercept to \code{fix.intercept} or estimate the intercept, default \code{fix.intercept = NULL}, which means estimate the intercept.
#' @param fix.eta Whether to fix the eta to \code{fix.eta} or estimate the eta, default \code{fix.eta = NULL}, which means estimate the eta. If \code{fix.eta} is not \code{NULL}, the eta will be fixed to \code{fix.eta}.
#' @param lim Tolerance limitation to ensure the positive-definiteness of covariance matrices, default \code{lim = exp(-18)}.
#' @param verbose Whether to print the log on the console, default \code{verbose = FALSE}.
#' @param lwr Lower bounds for \code{c(h2, intercept, eta, fold1, fold2, ..., foldn)}. Default is \code{NULL}, which means \code{c(0, 0, -2, 0, 0, ..., 0)}. When \code{fix.h2}, \code{fix.intercept} or \code{fix.eta} is not \code{NULL}, the lower bounds for \code{h2}, \code{intercept} or \code{eta} will be ignored.
#' @param upr Upper bounds for \code{c(h2, intercept, eta, fold1, fold2, ..., foldn)}, default is \code{NULL}, which means \code{c(1, 5, 1, M/Md_1, M/Md_2, ..., M/Md_n)}, where \code{Md_i} is the sum of the weights of the i-th annotation. When \code{fix.h2}, \code{fix.intercept} or \code{fix.eta} is not \code{NULL}, the upper bounds for \code{h2}, \code{intercept} or \code{eta} will be ignored.
#' @param maxit Maximum number of iterations, default maxit = 1000.
#' @param pgtol Tolerance for convergence, default pgtol = 1e-3.
#' @param par.h2 Whether to estimate the partitioned heritability, default \code{par.h2 = FALSE}.
#' @param mc.cores Number of cores to use for parallelization, default \code{mc.cores = 1}.
#' @param nthreads Number of threads to use for matrix operations, default \code{nthreads = 1}. The default value is suitable for most cases, do not change it unless you are sure about the performance.
#' @return A data.frame is returned with:
#' \itemize{
#' \item{item } The name of the parameter.
#' \item{estimation } The estimated value of the parameter.
#' \item{se } The standard error of the parameter.
#' \item{p } The p-value of the parameter.
#' \item{note } The note of the parameter.
#' }
#' @export

sHDL.optim <- function(ref.data, N,
  start.v=NULL, output.file=NULL, log.file="", stepwise=TRUE,
  fix.h2=NULL, fix.intercept=NULL, fix.eta=NULL, lim=exp(-18),
  verbose=FALSE, lwr=NULL, upr=NULL, maxit=1000, pgtol=1e-3,
  par.h2=FALSE, mc.cores=1, nthreads=1){
  t0 <- Sys.time()

  annots <- names(ref.data[[1]]$Md)
  M <- sum(unlist(lapply(ref.data, function(x) x$M)))
  Md <- colSums(do.call(rbind, lapply(ref.data, function(x) x$Md[annots])))
  names(Md) <- annots
  if(!is.null(fix.intercept) && !is.null(fix.h2)) stepwise <- FALSE
  if(!is.null(fix.h2)) h2.se <- NA
  if(!is.null(fix.intercept)) intercept.se <- NA

  for(i in seq_len(length(ref.data))){
    rank <- length(ref.data[[i]]$lam)
    ref.data[[i]]$zr <- ref.data[[i]]$zr[seq_len(rank)]
  }

  if(is.null(lwr)) lwr <- c(0, 0, -2, rep(0, length(Md)))
  if(is.null(upr)) upr <- c(1, 5, 1, M/Md)
  if(is.null(start.v)) start.v <- c(0.1, 1, 0, rep(1, length(Md)))

  if(!is.null(fix.eta)){
    start.v <- start.v[-3]
    lwr <- lwr[-3]
    upr <- upr[-3]
  }
  if(!is.null(fix.intercept)){
    start.v <- start.v[-2]
    lwr <- lwr[-2]
    upr <- upr[-2]
  }
  if(!is.null(fix.h2)){
    start.v <- start.v[-1]
    lwr <- lwr[-1]
    upr <- upr[-1]
  }

  if(stepwise){
    # optim h2 & intercept first
    ii <- seq_len(length(lwr) - length(Md))
    lam.all <- unlist(lapply(ref.data, function(x) x$lam))
    zr.all <- unlist(lapply(ref.data, function(x) x$zr))
    opt.first <- optim(
      start.v[ii], sHDL:::log.lik.HDL,
      lam=lam.all, zr=zr.all, N=N, M=M,
      fix.h2=fix.h2, fix.intercept=fix.intercept, fix.eta=fix.eta, lim=lim,
      method ="L-BFGS-B", lower=lwr[ii], upper=upr[ii], 
      hessian=TRUE, control=list(maxit=maxit, fnscale=-1, pgtol=pgtol)
    )

    se <- tryCatch(
      sqrt(diag(solve(-opt.first$hessian))),
      error = function(e){
        warn.msg <- "Hessian matrix is NOT invertible.\n"
        sHDL:::log.msg(warn.msg, log.file, type="warning")
        NA
      }
    )

    par <- rep(NA, 3)
    if(!is.null(fix.h2)) par[1] <- fix.h2
    if(!is.null(fix.intercept)) par[2] <- fix.intercept
    if(!is.null(fix.eta)) par[3] <- fix.eta
    par[is.na(par)] <- opt.first$par

    par.se <- rep(NA, 3)
    if(!is.null(fix.h2)) par.se[1] <- 0
    if(!is.null(fix.intercept)) par.se[2] <- 0
    if(!is.null(fix.eta)) par.se[3] <- 0
    par.se[is.na(par.se)] <- se

    h2 <- par[1]
    h2.se <- par.se[1]
    intercept <- par[2]
    intercept.se <- par.se[2]
    eta <- par[3]
    eta.se <- par.se[3]

    fix.h2 <- h2
    fix.intercept <- intercept
    fix.eta <- eta

    start.v <- start.v[-ii]
    lwr <- lwr[-ii]
    upr <- upr[-ii]
  }

  opt <- optim(
    start.v, sHDL:::log.lik.wg,
    ref.data=ref.data, Md=Md, M=M, N=N, log.file=log.file,
    fix.h2=fix.h2, fix.intercept=fix.intercept, fix.eta=fix.eta,
    verbose=verbose, lim=lim, mc.cores=mc.cores, nthreads=nthreads,
    method ="L-BFGS-B", lower=lwr, upper=upr,
    hessian=TRUE, control=list(maxit=maxit, fnscale=-1, pgtol=pgtol)
  )
  time <- as.numeric(Sys.time() - t0, units="secs")
  sHDL:::log.msg(sprintf("Optimization done in %.3f seconds.\n", time), log.file)
  covergence <- opt$convergence
  optim.message <- opt$message

  ## convert hessian to SE & p-value
  cov.m <- tryCatch(
    solve(-opt$hessian),
    error = function(e){
      warn.msg <- "Hessian matrix is NOT invertible.\n"
      sHDL:::log.msg(warn.msg, log.file, type="warning")
      matrix(NA, nrow=length(opt$par), ncol=length(opt$par))
    }
  )
  se <- sqrt(diag(cov.m))
  se <- as.numeric(se)

  npar <- length(opt$par)
  nann <- length(Md)
  folds <- opt$par[seq(npar - nann + 1, npar)]
  folds.se <- se[seq(npar - nann + 1, npar)]

  par <- rep(NA, 3)
  if(!is.null(fix.h2)) par[1] <- fix.h2
  if(!is.null(fix.intercept)) par[2] <- fix.intercept
  if(!is.null(fix.eta)) par[3] <- fix.eta
  ii <- is.na(par)
  par[ii] <- opt$par[seq_len(npar - nann)]

  par.se <- rep(NA, 3)
  if(exists("h2.se", envir = environment(), inherits = FALSE)) par.se[1] <- h2.se
  if(exists("intercept.se", envir = environment(), inherits = FALSE)) par.se[2] <- intercept.se
  if(exists("eta.se", envir = environment(), inherits = FALSE)) par.se[3] <- eta.se
  par.se[ii] <- se[seq_len(npar - nann)]

  h2 <- par[1]; h2.se <- par.se[1]
  intercept <- par[2]; intercept.se <- par.se[2]
  eta <- par[3]; eta.se <- par.se[3]

  folds.p <- pchisq(((folds-1)/folds.se)**2, df=1, lower.tail=FALSE)
  h2.p <- pchisq((h2/h2.se)**2, df=1, lower.tail=FALSE)
  intercept.p <- pchisq((intercept/intercept.se)**2, df=1, lower.tail=FALSE)
  eta.p <- pchisq((eta/eta.se)**2, df=1, lower.tail=FALSE)
  names(folds) <- names(folds.se) <- names(folds.p) <- annots

  if(par.h2){
    par.h2.se <- h2.se
    if(!is.null(fix.h2)){
      cov.h2.folds <- rep(0, length(folds))
      par.h2.se <- 0 ## set to 0 if h2 is fixed
    }else if(is.null(fix.intercept) && is.null(fix.eta)){
      ## remove the intercept & eta
      cov.h2.folds <- cov.m[1, , drop=TRUE][-c(1, 2, 3)]
    }else if(is.null(fix.intercept) || is.null(fix.eta)){
      ## remove the intercept or eta
      cov.h2.folds <- cov.m[1, , drop=TRUE][-c(1, 2)]
    }else{
      cov.h2.folds <- cov.m[1, , drop=TRUE][-1]
    }
    res.par.h2 <- sHDL:::est.par.h2(
      h2, par.h2.se, folds, folds.se, cov.h2.folds, Md, M
    )
    res.par.h2 <- data.frame(
      item=c(paste0("h2.", annots)),
      estimation=res.par.h2$ph2,
      se=res.par.h2$ph2.se,
      p=pchisq((res.par.h2$ph2/res.par.h2$ph2.se)**2, df=1, lower.tail=FALSE),
      note="partitioned heritability"
    )
  }

  ## combine the results
  res <- data.frame(
    item=c("time", "h2", "intercept", "eta", paste0("fold.", annots), "converged", "message"),
    estimation=c(time, h2, intercept, eta, folds, NA, NA),
    se=c(NA, h2.se, intercept.se, eta.se, folds.se, NA, NA),
    p=c(NA, h2.p, intercept.p, eta.p, folds.p, NA, NA),
    note=c("seconds", "total heritability", "intercept", "eta",
      rep("enrichment fold", length(annots)),
      as.character(covergence==0), optim.message
    )
  )

  if(par.h2){
    res <- rbind(res, res.par.h2)
  }
  rownames(res) <- NULL

  if(!is.null(output.file)){
    write.table(res, output.file, sep="\t", row.names=F, quote=F, col.names=T)
  }
  if(!is.null(log.file)){
    suppressWarnings(write.table(res, log.file, sep="\t", quote=F, row.names = F, col.names = T, append = TRUE))
  }
  return(res)
}